<?php
/**
 * Created by PhpStorm.
 * User: zhongyu
 * Date: 2020/10/9
 * Time: 11:31 AM
 */

class RedisApplications
{
    # read/write through 模式
    # Cache Aside 模式
    // 区别： 前者更新缓存，后者删除缓存，读取时再写入

    /** 系统升级重启或是缓存刚上线, 如何避免缓存雪崩问题？ */
    // 灰度发布方式, 先接入少量的请求, 后续逐步加大请求接入数量, 直到切换完成
    // 缓存预热, 将比较常用的数据提前进行缓存

    /** 如何减少Mysql和Redis模式下的缓存出现脏数据？*/
    // 数据加版本号, 更新缓存的时候只允许高版本覆盖低版本的

    /** Mysql 和 cache一致性问题 */
    // 当请求数量过大时，难免发生缓存穿透, 那我就不让他穿透, 缓存全量数据, 没问题, 有的公司就是这么干的
    // 但是, 这样一来系统更新完订单数据后如何去更新缓存呢 ？

    // solve1、Mq, 搞一个更新缓存的服务, 当系统更新订单数据时发送一条Mq的消息, 由更新缓存服务消费并更新
    // question: 消息丢失了, 缓存没法更新了 当下的kafka、rocketMq 配置正确基本可以实现可靠性

    // solve2、读取binLog(将当前服务伪装成mysql的从节点即可接受binLog), 更新缓存的服务从Mysql读取binLog, 根据binLog的变更信息去更新缓存
    // 相比较solve1, 减少了mq的环节, 出故障的可能性更低, 效率更高
    // question: 复杂, 不是直接接收消息, 而是需要读取binLog, 解析binLog的内容, 看起来有点难搞啊

    // 总结: 更新缓存的两种方式1、订阅更新消息Mq; 2、服务伪装成mysql的从节点解析binLog日志


}