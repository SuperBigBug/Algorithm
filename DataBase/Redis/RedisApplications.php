<?php
/**
 * Created by PhpStorm.
 * User: zhongyu
 * Date: 2020/10/9
 * Time: 11:31 AM
 */

class RedisApplications
{
    # read/write through 模式
    # Cache Aside 模式
    // 区别： 前者更新缓存，后者删除缓存，读取时再写入

    /** 系统升级重启或是缓存刚上线, 如何避免缓存雪崩问题？ */
    // 灰度发布方式, 先接入少量的请求, 后续逐步加大请求接入数量, 直到切换完成
    // 缓存预热, 将比较常用的数据提前进行缓存

    /** 如何减少Mysql和Redis模式下的缓存出现脏数据？*/
    // 数据加版本号, 更新缓存的时候只允许高版本覆盖低版本的

    /** '我的订单' 这种命中缓存不高的数据, 如何处理? 如何提高Mysql并发? */
    // 读写分离 (通常是读写比例不均衡的服务, 读写比在十几或是几十甚至更高)


    /** 分离应用程序的读写方法：*/
    // dao 层通过代码指向不同的数据库实例
    // 组件 Sharding-JDBC 这种集成在应用程序中的三方组件, 会自动把请求路由到对应的数据库上

    /** 主从同步带来的数据不一致问题: */
    // 主库写完同步到从库的这个微小的时间差叫做: 主从同步延迟
    // Question1：在购物车发起支付后在订单页确认支付瞬间返回支付前的订单页面，主库的订单状态已支付, 从库状态还未改变
    // 看见的效果是未支付
    // Solve1: 增加支付成功页面拖延时间, 哈哈哈哈

    // Question2: 购物车商品数量发生变化, 需要重新计价, 此时计价计算如果读取购物车的从库很有可能读到历史数据导致计价错误
    // Solve2: 更新购物车和计价放在一个事物中, 统一个事物中的查询和写的操作会被路由到同一个库 主库中




}