<?php
/**
 * Created by PhpStorm.
 * User: zhongyu
 * Date: 2020/10/9
 * Time: 3:13 PM
 */

class MysqlApplication
{
    /** '我的订单' 这种命中缓存不高的数据, 但是读的还比较多的如何处理? 如何提高Mysql并发? */
    // 读写分离 (通常是读写比例不均衡的服务, 读写比在十几或是几十甚至更高)


    /** 分离应用程序的读写方法：*/
    // dao 层通过代码指向不同的数据库实例
    // 组件 Sharding-JDBC 这种集成在应用程序中的三方组件, 会自动把请求路由到对应的数据库上

    /** 主从同步带来的数据不一致问题: */
    // 主库写完同步到从库的这个微小的时间差叫做: 主从同步延迟
    // Question1：在购物车发起支付后在订单页确认支付瞬间返回支付前的订单页面，主库的订单状态已支付, 从库状态还未改变
    // 看见的效果是未支付
    // Solve1: 增加支付成功页面拖延时间, 哈哈哈哈

    // Question2: 购物车商品数量发生变化, 需要重新计价, 此时计价计算如果读取购物车的从库很有可能读到历史数据导致计价错误
    // Solve2: 更新购物车和计价放在一个事物中, 统一个事物中的查询和写的操作会被路由到同一个库 主库中


    /** Mysql数据库如何主从同步的? */
    // 同步复制 : 实际应用基本不用
    // 1、性能差, 需要等复制给所有从库才结束
    // 2、可用性差, 主库于任意一个从库之间出现问题都会影响业务

    // 异步复制
    // 主库接受到客户端的请求后先写binLog后提交事务, 更新存储引擎中的数据事物提交完成后给客户端响应成功
    // 从库的复制线程接受binLog, 讲binLog写进中继日志, 然后给主库响应Success

    // 异步复制主库宕机存在丢数据风险、读写分离读到不一致数据问题

    /** 牛逼的来了, Mysql5.7以以后, 加入了半同步复制*/
    // 半同步复制 事物不需要等待所有复制成功的响应, 一部分复制成功后事物即事物提交给客户端响应

    // 主库事物线程等待复制结果超时, 会自动提交事务, Mysql会自动降级为异步复制模式, 直到有足够多的从库追上主库
    // 才会恢复半同步复制, 在此期间如果主库宕机, 仍然存在丢失数据风险

    /** 订单表, 越来越大, 怎么搞? */
    // 别急着分库分表, 可以先来个历史订单归档 将历史的订单拆分到某个表中,(3个月以前的) 订单表中新数据量就降下来了
    // 历史订单基本不需要做修改操作, 查询操作需要做出相应改动, 如当前订单, 历史三个月的订单, 和这个拆分就感觉比较配套了

    // 流程
    // 创建历史订单表 、 复制历史订单 、 上线验证 、 验证通过 删除历史订单，定期迁移
    //                                          验证不通过 回滚
    // 历史订单表结构 完全等同订订单, 大量的数据迁移尽量放在业务低峰期去迁移, 减少对线上主库的压力
    /**
     * create order_temp like order;
     *
     * insert into order_temp
     *      select * from order where create_time > xxxxx
     *
     * rename order to order_drop, order_temp to order
     * drop table order_drop
     */


    /** 删除大量订单表的历史数据怎么删除? */
    // 1、 delete from order where create_time < XXXXXXXXXXX
    // 如果数据量过大, 会报错, 不让一次删除过多数据

    // 2、delete from order where create_time < XXXXXXXXXXX limit 1000
    // 该sql可以执行, 但是每次删除之前会先筛选数据, 排序

    // 3、 优化
    // select max(id) from order where create_time < XXXXXXXXXXX
    // delete from order where id < ? limit 1000   Nice！

    /** 搞不定了搞不定了, 分库分表吧 */
    // 数据太多了, 查起来太慢了 好的 分表
    // 数据太多了, 并发还比较高 单个实例扛不住啊 好的 分库

    // 分片算法
    // 时间维度： 会出现某一时间片访问巨高甚至承受不住(热点问题), 其他片空闲, 并发请求和数据并未均匀落在n个片上
    // 哈希算法(取模算法)： 订单表不适合时间维度分片, 一般采用哈希算法分片, 如分24片可采取用用户id/24得到分片号
    // 取模算法的前提：Sharding key (用户id)的末尾数字必须是均匀的, 否则可能出现热点问题
    // 查表法：卧槽这也行, 这个真骚气
    // 查表法就是没有算法, 每次写入的时候记录一下分配的结果(这条数据写进了哪个表), 查询的时候先查下这个表, 知道分配到哪个表了直接去那个表查


}