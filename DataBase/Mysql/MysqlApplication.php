<?php
/**
 * Created by PhpStorm.
 * User: zhongyu
 * Date: 2020/10/9
 * Time: 3:13 PM
 */

class MysqlApplication
{
    /** '我的订单' 这种命中缓存不高的数据, 但是读的还比较多的如何处理? 如何提高Mysql并发? */
    // 读写分离 (通常是读写比例不均衡的服务, 读写比在十几或是几十甚至更高)


    /** 分离应用程序的读写方法：*/
    // dao 层通过代码指向不同的数据库实例
    // 组件 Sharding-JDBC 这种集成在应用程序中的三方组件, 会自动把请求路由到对应的数据库上

    /** 主从同步带来的数据不一致问题: */
    // 主库写完同步到从库的这个微小的时间差叫做: 主从同步延迟
    // Question1：在购物车发起支付后在订单页确认支付瞬间返回支付前的订单页面，主库的订单状态已支付, 从库状态还未改变
    // 看见的效果是未支付
    // Solve1: 增加支付成功页面拖延时间, 哈哈哈哈

    // Question2: 购物车商品数量发生变化, 需要重新计价, 此时计价计算如果读取购物车的从库很有可能读到历史数据导致计价错误
    // Solve2: 更新购物车和计价放在一个事物中, 统一个事物中的查询和写的操作会被路由到同一个库 主库中


    /** Mysql数据库如何主从同步的? */
    // 同步复制 : 实际应用基本不用
    // 1、性能差, 需要等复制给所有从库才结束
    // 2、可用性差, 主库于任意一个从库之间出现问题都会影响业务

    // 异步复制
    // 主库接受到客户端的请求后先写binLog后提交事务, 更新存储引擎中的数据事物提交完成后给客户端响应成功
    // 从库的复制线程接受binLog, 讲binLog写进中继日志, 然后给主库响应Success

    // 异步复制主库宕机存在丢数据风险、读写分离读到不一致数据问题

    /** 牛逼的来了, Mysql5.7以以后, 加入了半同步复制*/
    // 半同步复制 事物不需要等待所有复制成功的响应, 一部分复制成功后事物即事物提交给客户端响应

    // 主库事物线程等待复制结果超时, 会自动提交事务, Mysql会自动降级为异步复制模式, 直到有足够多的从库追上主库
    // 才会恢复半同步复制, 在此期间如果主库宕机, 仍然存在丢失数据风险


}